## 一. 说说TCP/IP的三次握手

### IP 协议

IP协议是**无连接的通信协议**, 他不会占用两个正在通信计算机之间的通信线路,这样 IP就降低了对网络线路的需求.每条线,**可以同时满足许多不同计算机之间的通信需要**.

通过IP消息或者其他数据, 会被分割为较小的独立的包，并通过因特网在计算机之间传送. IP负责将每个包路由至他的目的地，但IP协议没有做任何事情来确认数据包是否按顺序发送，或者包是否被破坏，所以**IP数据包是不可靠的，**所以需要由它的上层协议来做出控制

#### 总结

IP协议是无连接的, 所以特点是

1. 不会占用通信间的线路, 是每条线可以满足多次通信
2. 因为无连接, 所以没有任何确认, 是不可靠的, 需要上层协议规范

### TCP 协议

前面我们了解到, 传输控制协议TCP是属于传输层协议，那传输控制协议，他的英文名是transmission control protocol，缩写 就是我们的TCP了，**是一种面向连接的，可靠的，基于字节流的传输层通信协议**，数据传输时向TCP发送数据流， 然后TCP把数据流分割成适当长度的报文段，报文段的长度，通常是我们计算机连接的网络的数据流程的最大传输单元及MPU的限制，此后TCP把结果包传给IP层由他来通过网络， 将包传送给目标节点TCP层。

**TCP为了保证不丢失包，就给每个包一个序号**， 即 ACK number，同时， 序号也保证了传送到目标结点的包的按需处理。然后接收端实体对已成功收到的包发回一个相应的确认即ACK确认。如果发送端实体在合理的往返时间及***，未收到确认。那么对应的数据包就会被假设为已丢失，并且将会对其进行重传，TCP用一个奇偶校验和函数来检验数据是否有错误在发送和接收的同时,都要计算校验和

#### 总结一句话

TCP 解决可靠传输问题, 很多的数据分割成报文段, 每个包有个序号, 到了之后进行连接. 缺少哪个再重新发送

#### 特点

- 面向连接的，可靠的，基于字节流的传输层通信协议

  > 用于两个点线路之间的连接

- 应用层的数据流分割成报文段，并发送给目标节点的TCP层

  > 将数据分割成段

- 数据包都有序号, 对方收到则发送ACK确认, 未收到重传

  > 确保能够拼接成数据流,不能够少, 以及正确的拼接

- 使用校验和来检验数据在传输过程中是否有误

  > 保证传过来的数据是正确的

#### TCP报文头部

![TCP报文头首部格式](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\TCP报文头首部格式.png)

##### 解释: 

套接字 = IP + 端口号

##### TCP Flags (重要的三个)

- ACK: 确认序号标志
- SYN: 同步序列号,用于建立连接过程
- FIN: finish标志, 用于释放连接



## 三次握手



在TCP/IP协议中, TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

#### 流程图

![三次握手](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\三次握手.png)

#### 说明

SYN：建立连接

ACK：确认

ack：确认序号。等于对方发送序号+1（即对方期望收到的下一个序列号）

seq：发送序号。

CLOSED：没有连接状态

LISTEN：监听远方的TCP端口的连接请求

SYN-SENT：在发送方发送连接请求后等待对连接请求的确认。

SYN-RCVD：在接收方收到和发送一个连接请求后等待对连接请求的确认

ESTAB-LISHED：代表一个打开的连接，数据可以传递给双方。

#### 流程

1. **第一次握手:**建立连接时，客户端发送SYN包(seq = x)到服务器，并进入SYN_SENT状态,等待服务器确认:
2. **第二次握手:**服务器收到SYN包,必须确认客户的SYN(ack = x+1) ,同时自己也发送一个SYN包(syn = y) ,即SYN+ ACK包,此时服务器进入SYN_RECV状态;
3. **第三次握手:**客户端收到服务器的SYN+ ACK包,向服务器发送确认包ACK(ack = y+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手

### 为什么需要三次握手才能建立起连接

**主要是为了初始化 Sequence Number 的初始值**, 通信双方要相互通知自己的 Sqeuence Number值, 这个作为以后通信的序号, 以保证应用层接收到的数据不会因为网络上的传输问题而乱序, **即TCP会用这个序号来拼接数据**因此在服务器会发他的 Sequence Number, 及第二次握手之后呢,还需要发送确认报文给服务器, 告知服务器说, 客户端已经收到你的 Sequence Number了

#### 首次握手的隐患---SYN超时

###### 问题起因分析

* Server收到Client的SYN ,回复SYN-ACK的时候未收到ACK确认
* Server不断重试直至超时, Linux默认等待63秒才断开连接( 连接5次, 1 + 2 + 4 + 16 + 32)

可能遭到 SYN Flood的攻击的风险

###### 针对SYN Flood的防护措施

* SYN队列满后,通过tcp_ syncookies参数回发SYN Cookie
* 若为正常连接则Client会回发SYN Cookie ,直接建立连接 

#### 建立连接后, Client出现故障怎么办

###### 保活机制

* 向对方发送保活探测报文,如果未收到响应则继续发送
* 尝试次数达到保活探测数仍未收到响应则中断连接

## 二. 谈谈 TCP的四次挥手

挥手是为了终止连接, TCP 四次

#### 流程图

![四次挥手](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\四次挥手.png)

#### 说明

FIN：结束
FIN-WAIT-1：等待远程TCP连接的中断请求，或者之前的连接中断请求的确认。
FIN-WAIT-2：从远程TCP等待连接中断请求。
CLOSE-WAIT：等待从本地用户发来的连接中断请求。
LAST-ACK：等待原来发向远程TCP的连接中断请求的确认
TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认。
CLOSED：没有任何连接状态。

#### 挥手过程

**第一次挥手：**客户端A发送FIN包，用来关闭与服务器B之间的数据传输，同时发送发送序号为u，客户端A进入等待状态。（关闭服务器读通道）。

**第二次挥手：**服务器B收到FIN包，发送ACK确认报文，确认序号为u+1，发送序号为v，客户端A收到服务器B的确认后，进入FIN-WAIT-2等待状态，等待B发送报文。（关闭客户端写通道）

**第三次挥手：**服务器B关闭与客户端A的连接，发送一个FIN包给客户端，进入最后确认状态CLOSE-WAIT。（关闭客户端读通道）

**第四次挥手：**客户端A收到服务器发送的报文后，发送ACK确认报文，表示对B的释放请求发出确认，并且将确认序号设置为收到序号+1，然后进入TIME-WAIT时间等待状态。（关闭服务器写通道）

### 为什么会有TIME_WAIT 状态

超时时间为 2 * MSL, 为什么需要等待时间

#### 原因

* 确保有足够的时间让对方收到 ACK包

  > 如果被动关闭的一方没有收到 ACK, 被动端就会重发 FIN包, 一来一去正好是 2个 MSL

* 避免新旧连接混淆

  > 有足够的时间让这个连接不会和后面的连接混在一起. 有些路由器会缓存IP数据包, 如果连接被重用了, 那么这些延迟收到的包,就有可能跟新连接混在一起

### 为什么需要四次握手才能断开连接

因为客户端的LISTEN状态下的SOCKET收到SYN报文的连接请求后，它可以把ACK和SYN放在一个报文里来发送。但关闭连接时，当收到对方的FIN通知时，它仅仅表示对方没有数据发送给你，但并不代表你不会给它发送数据，所以你可能不会立即关闭SOCKET，而是发送FIN报文给对方表示你同意现在可以关闭连接了，所以这里的ACK报文和FIN报文多数情况下是分开发送的。



因为全双工(允许在两个方向上同时传输), 发送发和接收方都需要 FIN报文和 ACK报文

也就是发送发和接收方都需要两次挥手即可, 不过有一方是被动的, 所以看上去是四次挥手

### 服务器出现大量 CLOSE_WAIT 状态的原因

客户端一直在请求,但是返回给客户端的信息出现异常, 服务端没有收到请求

也就是对方关闭 Socket连接, 我方忙于读或写, 没有即使关闭连接

###### 解决

* 检查代码, 特别是释放资源的代码
* 检查配置, 特别是处理请求的线程配置

> netstat 指令重要

## 三. UDP

#### 报文结构

![UDP报文头](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\UDP报文头.png)

#### UDP 特点

* 面向非连接

* 不维护连接状态, 支持同时向多个客户端传输相同的消息

  > 如广播

* 数据包只有 8个字节, 额外开销较小

* 吞吐量只受限于数据生成速率, 传输速率以及机器性能

  > 效率高, 比如看电影等都是采用这种

* 尽最大努力交付, 即不保证可靠交付, 不需要维持复杂的连接状态表

* 面向报文, 不对应用程序提交的报文信息进行拆分或者合并

### TCP/ UDP区别

#### 结论

![TCP_UDP区别](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\TCP_UDP区别.png)

**补:** TCP是有序的, UDP是无序的



