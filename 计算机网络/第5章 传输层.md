# 传输层







### 位置

![位置](E:\Git\秋招_基础知识\计算机网络\图片\第5章\位置.png)

### 信息处理角度

从信息的处理角度去看, 传输层主要是给应用层提供通信服务的, 对网络进行编程的时候, 很多时候都是直接对接传输层, 使用传输层提供的接口进行网络的编程. 

传输层是用户功能里面的最底层, 属于面向通信部分的最高层. 

![终端的位置](E:\Git\秋招_基础知识\计算机网络\图片\第5章\终端的位置.png)

网络中的路由器是并没有传输层在工作的. 也就是传输层在工作的位置是终端的设备, 因此传输层的工作是管理端到端的通信连接

由于由网络层和数据链路层以及物理层功能的提供, 才使得传输层可以关注端到端的通信连接. 

网络层提出了虚拟互联网络. 对于网络, 不同的终端设备可以进行不需要关心网络拓扑. 只关心如何进行虚拟的网络路由. 决定数据的走向. 

### 通信过程

传输层重点关心两个设备之间是如何进行通信的. 

![进行通信](E:\Git\秋招_基础知识\计算机网络\图片\第5章\进行通信.png)

假设用户在计算机 A打开了浏览器. 计算机 B运行着网站后台. 浏览器需要浏览网站. 通过虚拟的互连网络访问到网站的后台. 然后取得计算机 B的数据, 

浏览器和网站后台在运行的时期都是一个进程. 所以也可以看作是进程与进程之间的通信. 

#### 进程与进程的通信

* 单机之间的通信 (不能跨网络和机器)
  * 共享内存
  * Unix域套接字

* 多个机器之间的通信 ((可以跨网络和机器))
  * 网络通信

前面的知识离用户很遥远. 学习网络层的时候发现网络离用户又进了一点点. 传输层工作的本质是进行进程与进程的通信(跨设备). 离我们的用户又进了一步. 网络的特点, 从下往上, 离我们用户越接近. 

如何识别是计算机的哪个进程在进行通信的呢? 

### 端口

* 使用端口(Port)来标记不同的网络进程

* 端口(Port)使用 16位比特表示 (0~65535)

* 常用端口

  ![常用端口](E:\Git\秋招_基础知识\计算机网络\图片\第5章\常用端口.png)



# 套接字与套接字编程

IP和端口的组合就叫套接字

![套接字](E:\Git\秋招_基础知识\计算机网络\图片\第5章\套接字.png)



* 套接字 (Socket)是抽象概念, 表示 TCP连接的一端

  > 并不是一个新的东西, 只不过是一个组合的名字, TCP是点到点的通信. 两个端点之间会有一个 TCP连接来进行通信. 

* 通过套接字可以进行数据发送或者接收

  > 对网络进行编程的时候实际上是对套接字进行编程的



![TCP等式](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP等式.png)

TCP由两个套接字组成, 通过两个套接字可以确定一个 TCP的连接. 

#### 架构

![CS架构](E:\Git\秋招_基础知识\计算机网络\图片\第5章\CS架构.png)

使用 Socket来进行数据的发送和接收的.  



# UDP协议

### 概念

* UDP(User Datagram Protocol): 用户数据报协议

* UDP是一个非常简单的协议

* 数据报就是应用层传输过来的一个完整的数据. 不会对数据进行任何的处理(不会合并或者拆分). 

  > UDP协议的长度主要是由业务层传输的长度所决定的. 

#### 协议位置

![UDP的位置](E:\Git\秋招_基础知识\计算机网络\图片\第5章\UDP的位置.png)

#### UDP的首部

![UDP的首部](E:\Git\秋招_基础知识\计算机网络\图片\第5章\UDP的首部.png)

* 16位源端口号: 原机器使用网络的进程
* 16位目的端口号: 目的机器使用网络的进程
* 16位 UDP长度: UDP数据报的长度, 包括 UDP的数据, 最小值为 8个字节(只有首部)
* 16位 UDP校验和: 检测 UDP的数据报再传输过程中是否发生出错. 

非常简单的头部

### 特点

#### 1. UDP是无连接协议

##### 什么是连接? 

```
假设要进行电话通信, 
1. 通信之前要拿出手机拨通电话, 这就相当于建立连接. 
2. 电话拨通之后, 说明连接成功的建立起来了. 
3. 之后就可以进行通信了. 
4. 电话通信结束后, 把电话挂断, 这就相当于把连接结束掉. 
```

UDP并不需要提前建立连接, 只要想发就发送出去

![UDP无连接](E:\Git\秋招_基础知识\计算机网络\图片\第5章\UDP无连接.png)

#### 2. UDP不能保证可靠的交付

* 因为想发就发, 无法保证数据在网络中是否丢失

* 因为UDP头部的简单, 也没有提供任何机制数据可以有效的到达对方. 所以不能保证是否有丢失

* 即使有丢失的话也不会感知到. 

#### 3. UDP是面向报文传输的

报文就是上面的数据报, 其实就是应用层传输过来的完整数据. 对于数据 UDP没有进行任何处理, 而是直接塞进UDP协议, 所以是面向报文传输的. 与之相对的是TCP协议不是面向报文进行传输的. 

![UDP数据报](E:\Git\秋招_基础知识\计算机网络\图片\第5章\UDP数据报.png)

#### 4. UDP没有拥塞控制

**什么是拥塞控制?**

把网络看作是一个公路网, 如果车流多, 就会造成拥塞. 

UDP不会感知网络是否拥塞. 不管网络是否发生拥塞, 都会尽量的把数据交付出去.

#### 5. UDP首部开销很小

只有四个关键的内容, 一共才 8个字节

 

# TCP协议

## 简介

* TCP (Transmission Control Protocol): 传输控制协议
* TCP协议是计算机网络中非常复杂的一个协议

### 位置

![TCP的位置](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP的位置.png)

### 特点

对比 UDP协议

* TCP是面向连接的协议

  > TCP要通信的话, 首先要建立起 TCP的连接. 也就是打电话要先拨通电话, 结束后需要挂断

* TCP的一个连接有两段(点对点通信)

  > 我和你进行电话通信, 我和你就是两个点

* TCP提供可靠的传输服务

  > 后面会进行了解

* TCP协议提供全双工的通信

  > 全双工就是我和你在打电话时同时可以进行对话.
  >
  > 两个计算机都可以同时的向连接里面发送或者接收数据 

* TCP是面向字节流的协议

  > 字节流和数据报的区别. 流是指流入进程和流出进程的字节序列
  >
  > 传输层的数据都是由应用层传输下来的, 是一块一块的, 但是 TCP并不把他看成是一块完整的数据, 而是把他看作是一系列的, 一整串的字节流. 所以可能取出某一段进行传输. 而剩下的放入后面的TCP报文进行传输. 因此在 TCP中可能对用户的数据块进行合并, 也可能进行分拆. 

  ![面向字节流](E:\Git\秋招_基础知识\计算机网络\图片\第5章\面向字节流.png)

### TCP协议头部

![TCP头部](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP头部.png)

#### 解析

#### 第一行: 

和UDP的解释相同

#### 第二行

* 序号是 32个比特位. 所以范围是 0 ~ 2^32 - 1

* 一个字节就有一个序号. 

  > TCP是面向字节流的, 所以每一个字节都有一个唯一的序号. 用来标记传输的字节

* 数据首字节序号

  > 序号代表这个 TCP报文所传输的数据的第一个数据的序号是什么

  ![序号](E:\Git\秋招_基础知识\计算机网络\图片\第5章\序号.png)

#### 第三行

* 确认号是 32个比特位. 所以范围是 0 ~ 2^32 - 1

* 一个字节一个序号

* 期望收到数据的首字节序号

  > 我希望收到的下一个数据报里面数据的首字节序号, 配合着序号一起来使用的

  ![确认号](E:\Git\秋招_基础知识\计算机网络\图片\第5章\确认号.png)

#### 第四行

* 数据偏移: 

  * 占 4位: 0~15, 单位为: 32位字

    > 每一个偏移都可以表示四个字节的偏移

  * 数据偏离首部的距离

    > 真实 TCP的数据偏离首部的距离, 由于 TCP选项块的内容所导致的, 因为不知道选项的内容有多少

    ![TCP首部大小](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP首部大小.png)

* 保留字段: 保留着的, 还未使用的

* TCP标记:

  * 占 6位, 每位各有不同的含义

  ![TCP标记](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP标记.png)

* 窗口: 是TCP滑动窗口协议里面的重要组成部分

  * 占16位: 0 ~ 2^16 - 1

  * 窗口指明允许对方发送的数据量

    > 如果窗口值是 1000, 也就表示对方可以发送 1000个字节给我
    >
    > 窗口结合确认号进行运算, 比如确认号是 501, 窗口的值是 1000, 那么从 501 - 1500这么多个字节的数据都是可以接收的

#### 第五行

* 校验和

* 紧急指针

  * 紧急数据 (URG = 1的时候才会启用)

  * 指定紧急数据在报文的位置

    > 对于 TCP报文来说, 有部分的紧急数据是可以保存在数据报里面的. 到对方的时候, 就可以通过紧急指针来指定紧急数据位于的位置

#### 第六行

* TCP选项

  * 除了固定的 20个字节以外, 数据的 TCP选项最多有 40个字节可以使用
  * 支持协议未来的发展

  ![TCP首部大小](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP首部大小.png)

通过头部可以感到协议可以做什么样子的工作. 



# 可靠传输的基本原理

### 停止等待协议

* 停止等待协议是最简单的可靠传输协议

* 对信道的利用率不高

  > 发送方需要进行等待确认消息回来再发送, 信道利用率较低

#### 情况一

![停止等待协议无差错情况](E:\Git\秋招_基础知识\计算机网络\图片\第5章\停止等待协议无差错情况.png)

#### 过程

1. 发送方建立起 TCP的数据, 发送出去, 经过一段时间发送到接收方
2. 接受方将确认的消息(表示你发送的消息我已经接收到了, 给你发送确认)发送给发送方, 经过一段时间发送到发送方
3. 发送方知道了已经接收到了消息 1, 又会发送消息 2给接收方
4. ….

##### 停止在了什么地方, 等待在什么地方

发送方发送了一个消息, 停止生成新的消息, 等待接收方的确认消息到达发送方之后, 再生成第二个消息, 这就死停止, 等待, 停止, 等待, 的过程. 接收方也是类似的.

#### 情况二

![停止等待协议超时重传](E:\Git\秋招_基础知识\计算机网络\图片\第5章\停止等待协议超时重传.png)

1. 假如发送方发送的消息在发送过程中丢失了, 接收方并没有接收到消息, 
2. 等待一段时间之后发现对方并没有发送确认消息回来
3. 重新发送这个消息(超时重传)
4. …

可以进行可靠传输

#### 情况三

![停止等待协议超时重传2](E:\Git\秋招_基础知识\计算机网络\图片\第5章\停止等待协议超时重传2.png)

1. 确认的消息在传输过程中丢失了

2. 发送方没有收到确认消息. (超时重传)
3. 重新发送这个消息(超时重传)
4. …

#### 情况四

![停止等待协议超时重传3](E:\Git\秋招_基础知识\计算机网络\图片\第5章\停止等待协议超时重传3.png)

1. 确认消息在传输过程中经历了很久在到达发送方
2. 发送方一定时间内没有收到确认消息. (超时重传)
3. 重新发送这个消息(超时重传)
4. …

#### 总结

三种超时的情况

* 发送的消息在路上丢失了
* 确认的消息在路上随时了
* 确认的消息很久才到

通过超时重传来保证**可靠传输**

#### 超时定时器

* 每发送一个消息, 都需要设置一个定时器

  > 用于计算消息什么时候过期了



### 连续ARQ协议

* ARQ(Automatic Repeat ReQuest): 自动重传请求

  > 既然单个发送和确认效率低, 可以进行批量发送和确认

#### 过程

![连续ARQ协议](E:\Git\秋招_基础知识\计算机网络\图片\第5章\连续ARQ协议.png)

1. 连续发送 6个报文, 收到 1和 2两个报文
2. 窗口向前移动两个位置, 继续发送 7和 8
3. 等待新的到达之后再把窗口向右移动, 
4. 批量发送大小称为窗口, 可以向前推进, 所以称为滑动窗口
5. 会批量的发送数据, 只要前面的数据确认消息到达后, 会将窗口向右移动. 继续发送窗口内部还未发送的数据. 这就属于滑动窗口的工作过程. 窗口里面的数据都可以发送.

如果滑动窗口每一个报文都需要确认的话, 确认消息的开销都是很大的. 因此并不需要对每一个窗口都进行确认, 而是采用累积确认的方法. 什么是累积确认

![累积确认](E:\Git\秋招_基础知识\计算机网络\图片\第5章\累积确认.png)

1. 假设某个时刻发送了 1~ 6的报文
2. 在某一个时刻发送方收到了第五的确认消息. 如果采用累积确认, 表示 1~ 5的消息都已经收到了. 那么因此会将窗口向前推动 5格. 窗口可以发送 7 - 11的数据
3. 只要我收到某一个消息的确认, 就表示说这个消息之前的消息我都已经收到了. 累积确认减少了确认报文的数量以此来提升网络的效率. 



## TCP的可靠传输

三个比较重要的 TCP标记, 会在进行 TCP连接或者释放时所使用到的. 

![TCP连接和释放所使用到的TCP标记](E:\Git\秋招_基础知识\计算机网络\图片\第5章\TCP连接和释放所使用到的TCP标记.png)



#### 握手过程



发送方要主动和接收方建立起连接, 

1. **第一次握手:** 建立连接时，客户端发送报文, 进入 SYN_SENT状态, 等待服务器确认

   > 报文信息: 
   >
   > SYN = 1: 表示这是连接请求报文
   >
   > seq = x : 在报文中还会同步自己的序列号

2. **第二次握手:** 接收方在接收到报文之后, 也会被动的打开 TCP连接, 同时也会发出一个报文,

   > 报文信息: 
   >
   > SYN = 1: 表示这是连接请求的信息
   >
   > ACK = 1 : 表示确认号是有用的, 和 ack结合着来看
   >
   > ack = x + 1 : 是确认号, 表示期望收到 x + 1的序列号的值
   >
   > seq = y : 当前自己的序列号

3. 发送方接收到消息之后, 也会进行一个回应, 

   > 报文信息: 
   >
   > ACK = 1 : 表示确认号是有用的, 和 ack结合着来看
   >
   > ack = y + 1 : 是确认号, 表示期望收到 y + 1的序列号的值
   >
   > seq = x + 1 : 同步自己的序列号位 x + 1, 表示当前发送数据的序列号位 x + 1



对于第一次和第二次都是有 SYN的标记, 表示连接请求的意思. 

对于第二次和第三次都是有 ACK的标记, 表示先对连接双方的序列号进行同步, 

通过三次握手不仅仅把 TCP的连接建立起来, 而且也同步了各自的序号. 这就是三次握手的过程. 



#### 为什么发送发要发送第三个确认报文? 

或者问为什么两次握手不行呢? 

答: 为了避免已经**失效的连接请求报文**传送到对方, **引起错误**

怎么来的

假设发送方第一次发送的请求报文过了很久才到达接受方, 发送方很久都没有收到确认消息. 发送方就认为第一个报文超时了, 就会发送第二个报文(正常情况到达), 接收方接收到之后就会做出回应, 建立起连接, 

对于第一个请求来说, 就是一个失效的请求报文, 因为他的功能已经被第二次的请求所完成了. 

 但是对于第一个请求也会建立起连接, 因为只要接收方回应了, 就代表建立连接了. 因此两次握手也可以建立起连接. 就会建立两次 TCP连接的情况. 这个情况是错误的. 

三次握手如何解决的问题? 

![三次握手解决问题](E:\Git\秋招_基础知识\计算机网络\图片\第5章\三次握手解决问题.png)

第一次确认到达发送方后, 发送方会在发送一个报文表示确认

慢的报文也会发送一个确认给发送方, 但是发送方已经进行了三次握手了, 所以发送方对于第二次的确认消息会忽略掉, 并不会进行任何的操作.  







1. 建立连接时，客户端发送报文SYN = 1, 表示这是连接请求报文(seq = x)到服务器，并进入SYN_SENT状态,
2. **第二次握手:**服务器收到SYN包,必须确认客户的SYN(ack = x+1) ,同时自己也发送一个SYN包(syn = y) ,即SYN+ ACK包,此时服务器进入SYN_RECV状态;
3. **第三次握手:**客户端收到服务器的SYN+ ACK包,向服务器发送确认包ACK(ack = y+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手



## TCP连接的释放(四次挥手)



连接正常的时候是可以进行数据传输的. 假设数据传输已经完成了. 双方都可能进行连接的释放. 假设发送方主动进行连接的释放

1. 发送方发送一个特殊的报文, 进入 FIN-WAIT-1 状态, 连接结束第一个等待状态

   > 数据信息: 
   >
   > FIN = 1 : 表示需要释放链接
   >
   > seq = u

2. 接收方接收到了报文之后, 发送报文进行确认, 进入 CLOSE-WAIT状态, 关闭等待状态, 对于接收方的关闭等待状态, 接收方在这个状态之后还是可以进行数据的发送. 

   > 数据信息: 
   >
   > ACK = 1: 
   >
   > seq = v : 
   >
   > ack = u+1

3. 发送方接收到了接收方的确认报文, 进入第二个状态 FIN-WAIT-2, 连接结束第二个等待状态

4. 接收方发送完数据之后, 又会发出一个新的报文, 进入 LAST-ACK状态, 最后确认状态

   > 数据信息:
   >
   > FIN = 1
   >
   > ACK = 1 : 对第一个报文进行确认
   >
   > seq = w
   >
   > ack = u + 1

5.  发送方在接收到第三个报文之后, 又会发出一个确认, 确认你给我发送的释放信号我已经收到了. 现在就把连接释放掉, 进入 TIME-WAIT状态, 时间等待状态, 等待一段时间, 确保这段时间里面没有出现任何问题, 进入关闭状态. 

     

主动释放的一方有一个时间等待状态. 之后才进入关闭状态. 接收方在最后确认状态之后进入关闭状态



### 等待计时器

等待计时器会等待 2MSL的时间 

MSL(Max Segment Lifetime): 最长报文段寿命

对于一般的网络来说, MSL建议设置为 2分钟. 



对于每一个 TCP连接, 都会占用一个端口, 在连接的状态里面. 如果想起用另一个网络状态的进程去复用这个端口, 是不可以的. 因为这个端口已经被占用了. 会提示说端口被占用. 

等待计时器在这个状态是不会释放连接的. 也就是说不会释放端口, 只有在等待计时器之后才会释放端口



如果主动的释放了连接, 想要马上重复复用这个端口是不行的, 因为有等待计时状态. 



为什么需要等待计时器, 

只要发送方发送了第四次挥手的报文之后, 就进入了等待的状态, 

此时最后一个报文是并没有确认的

确保发送发的 ACK可以达到接收方. 

2MSL时间内接收方没有接收到, 则接收方会将第三次挥手的报文重新发送给接收方

接收方就知道了我发送的挥手报文没有收到, 于是重新发送第四次挥手 



主要是为了确保发送方发送的第四个挥手报文可以正确的到达对方, 如果没有到达, 接收方会重新发送第三次报文, 



第二个功能

* 确保当前连接的所有报文都已经过期. 
* 因为最后一个报文都等待了 2MSL, 对于其他报文肯定也是超过 2MSL, 所以对于其他报文来说肯定都是过期的baowen





### 套接字编程

#### 步骤

![套接字编程](E:\Git\秋招_基础知识\计算机网络\图片\第5章\套接字编程.png)