# 介绍一下 TCP/IP

#### 一句话理解

OSI太复杂了, 实现不了, 真正的落地产品是 TCP/IP, (对OSI进行了简化)

#### OSI 局限性

OSI是一个定义良好的协议规范期，并有许多可选部分完成类似的任务，它定义了开放系统的层次结构，层次之间的相互关系以及各层所包括的可能的任务，是作为一个框架来协调和组织课程所提供的服务，但是OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定，即OSI参考模型并不是一个标准，**而是一个在制定标准时所使用的概念性框架**

### TCP/IP 诞生

事实上标准是TCP/IP 4层架构参考模型，TCP IP参考模型是首先***所使用的网络体系结构，后来该结构被美国国防部用来作为计算机网络的标准，由于领头大哥的推动，市面上绝大多数厂商也以该标准为主用以商用，虽然TCP/IP协议，并不完全符合OSI的7层参考模型，但我们依然可以理解为它是OSI的一种实现

### 理解

从字面上讲有人可能会认为TCP/IP是指TCP和IP这两种协议，实际生活当中有时也确实就是指这两种协议，然而在很多情况下，**它只是利用IP进行通信时所必须用到的协议群的统称**，具体来说IP或者ICMP，TCP, 或者用UDP, 或者FTP以及HTTP等等.是互联网必不可少的组成部分

TCP/IP协议泛指这些协议，因此，有时也称TCP/IP为网际协议群，从图里我们得知了，TCP/IP协议与OSI在分层模块上稍有区别

##### 图示

![模型区别](E:\Git\秋招_基础知识\计算机网络\图片\TCP_IP\模型区别.png)



#### 区别

* **层级上**
  * TCP/IP的应用层，可以理解为约等于OSI中的应用层表示层和会话层这三层的组合
  * 同时OSI的数据链路程以及物理层，在TCP/IP中呢，被归并为链路层

* **着重上**
  * OSI 模型，注重通信协议必要的功能是什么, TCP/IP呢，更强调在计算机上实现协议应该开发哪种程序

#### 参考模型

![TCP_IP参考模型](E:/Git/%E7%A7%8B%E6%8B%9B_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E7%89%87/TCP_IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.jpg)

####  

​	在数据传输的过程中，我们可以看到和OSI 一样，TCP/IP的每个分层中呢，都会对所发送的数据，附加一个头部，在这个首部中，包含了该层必要的信息，如发送的目标地址以及协议相关信息，通常为协议提供的信息为报头的首部，所要发送的内容为数据,从下一层角度上看,数据被传送到接收端后, 再层层被解刨出来



# 网络层

### IP 协议

IP协议是**无连接的通信协议**, 他不会占用两个正在通信计算机之间的通信线路,这样 IP就降低了对网络线路的需求.每条线,**可以同时满足许多不同计算机之间的通信需要**.

通过IP消息或者其他数据, 会被分割为较小的独立的包，并通过因特网在计算机之间传送. IP负责将每个包路由至他的目的地，但IP协议没有做任何事情来确认数据包是否按顺序发送，或者包是否被破坏，所以**IP数据包是不可靠的，**所以需要由它的上层协议来做出控制

#### 总结

IP协议是无连接的, 所以特点是

1. 不会占用通信间的线路, 是每条线可以满足多次通信
2. 因为无连接, 所以没有任何确认, 是不可靠的, 需要上层协议规范

# 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

#### UDP 和 TCP 的特点

- 用户数据报协议 UDP（User Datagram Protocol）是**无连接的，尽最大可能交付，**没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 TCP（Transmission Control Protocol）是**面向连接的，提供可靠交付**，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

## UDP

###### 图一

![UDP报文段](E:\Git\秋招_基础知识\计算机网络\图片\TCP_IP\UDP报文段.jpg)

###### 图二

![UDP报文头](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\UDP报文头.png)

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

#### UDP 特点

- 面向非连接

- 不维护连接状态, 支持同时向多个客户端传输相同的消息

  > 如广播

- 数据包只有 8个字节, 额外开销较小

- 吞吐量只受限于数据生成速率, 传输速率以及机器性能

  > 效率高, 比如看电影等都是采用这种

- 尽最大努力交付, 即不保证可靠交付, 不需要维持复杂的连接状态表

- 面向报文, 不对应用程序提交的报文信息进行拆分或者合并



## TCP 协议

前面我们了解到, 传输控制协议TCP是属于传输层协议，那传输控制协议，他的英文名是transmission control protocol，缩写 就是我们的TCP了，**是一种面向连接的，可靠的，基于字节流的传输层通信协议**，数据传输时向TCP发送数据流， 然后TCP把数据流分割成适当长度的报文段，报文段的长度，通常是我们计算机连接的网络的数据流程的最大传输单元及MPU的限制，此后TCP把结果包传给IP层由他来通过网络， 将包传送给目标节点TCP层。

**TCP为了保证不丢失包，就给每个包一个序号**， 即 ACK number，同时， 序号也保证了传送到目标结点的包的按需处理。然后接收端实体对已成功收到的包发回一个相应的确认即ACK确认。如果发送端实体在合理的往返时间及***，未收到确认。那么对应的数据包就会被假设为已丢失，并且将会对其进行重传，TCP用一个奇偶校验和函数来检验数据是否有错误在发送和接收的同时,都要计算校验和

#### 总结

TCP 解决可靠传输问题, 很多的数据分割成报文段, 每个包有个序号, 到了之后进行连接. 缺少哪个再重新发送

#### 特点

- 面向连接的，可靠的，基于字节流的传输层通信协议

  > 用于两个点线路之间的连接

- 应用层的数据流分割成报文段，并发送给目标节点的TCP层

  > 将数据分割成段

- 数据包都有序号, 对方收到则发送ACK确认, 未收到重传

  > 确保能够拼接成数据流,不能够少, 以及正确的拼接

- 使用校验和来检验数据在传输过程中是否有误

  > 保证传过来的数据是正确的

#### TCP报文头部

![TCP报文头首部格式](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\TCP报文头首部格式.png)

##### 解释: 

套接字 = IP + 端口号

##### TCP Flags (重要的三个)

- **序号:** 用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100字节，那么下一个报文段的序号应为 401。
- **确认号:** 期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移:** 指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK:** 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把ACK 置 1。
- **同步 SYN:** 在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN:** 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口:** 窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的



### 三次握手

在TCP/IP协议中, TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

##### 流程图

![三次握手](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\三次握手.png)

#### 说明

SYN：建立连接

ACK：确认

ack：确认序号。等于对方发送序号+1（即对方期望收到的下一个序列号）

seq：发送序号。

CLOSED：没有连接状态

LISTEN：监听远方的TCP端口的连接请求

SYN-SENT：在发送方发送连接请求后等待对连接请求的确认。

SYN-RCVD：在接收方收到和发送一个连接请求后等待对连接请求的确认

ESTAB-LISHED：代表一个打开的连接，数据可以传递给双方。

#### 握手过程

1. **第一次握手:**建立连接时，客户端发送SYN包(seq = x)到服务器，并进入SYN_SENT状态,等待服务器确认:
2. **第二次握手:**服务器收到SYN包,必须确认客户的SYN(ack = x+1) ,同时自己也发送一个SYN包(syn = y) ,即SYN+ ACK包,此时服务器进入SYN_RECV状态;
3. **第三次握手:**客户端收到服务器的SYN+ ACK包,向服务器发送确认包ACK(ack = y+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手

#### 1. 为什么需要三次握手才能建立起连接

**主要是为了初始化 Sequence Number 的初始值**, 通信双方要相互通知自己的 Sqeuence Number值, 这个作为以后通信的序号, 以保证应用层接收到的数据不会因为网络上的传输问题而乱序, **即TCP会用这个序号来拼接数据**因此在服务器会发他的 Sequence Number, 及第二次握手之后呢,还需要发送确认报文给服务器, 告知服务器说, 客户端已经收到你的 Sequence Number了

#### 2. 首次握手的隐患---SYN超时

###### 问题起因分析

- Server收到Client的SYN ,回复SYN-ACK的时候未收到ACK确认
- Server不断重试直至超时, Linux默认等待63秒才断开连接( 连接5次, 1 + 2 + 4 + 16 + 32)

可能遭到 SYN Flood的攻击的风险

###### 针对SYN Flood的防护措施

- SYN队列满后,通过tcp_ syncookies参数回发SYN Cookie
- 若为正常连接则Client会回发SYN Cookie ,直接建立连接 

#### 3. 建立连接后, Client出现故障怎么办

###### 保活机制

- 向对方发送保活探测报文,如果未收到响应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接

### TCP的四次挥手

挥手是为了终止连接, TCP 四次

##### 流程图

![四次挥手](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\四次挥手.png)

#### 说明

FIN：结束
FIN-WAIT-1：等待远程TCP连接的中断请求，或者之前的连接中断请求的确认。
FIN-WAIT-2：从远程TCP等待连接中断请求。
CLOSE-WAIT：等待从本地用户发来的连接中断请求。
LAST-ACK：等待原来发向远程TCP的连接中断请求的确认
TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认。
CLOSED：没有任何连接状态。

#### 挥手过程

**第一次挥手：**客户端A发送FIN包，用来关闭与服务器B之间的数据传输，同时发送发送序号为u，客户端A进入等待状态。（关闭服务器读通道）。

**第二次挥手：**服务器B收到FIN包，发送ACK确认报文，确认序号为u+1，发送序号为v，客户端A收到服务器B的确认后，进入FIN-WAIT-2等待状态，等待B发送报文。（关闭客户端写通道）

**第三次挥手：**服务器B关闭与客户端A的连接，发送一个FIN包给客户端，进入最后确认状态CLOSE-WAIT。（关闭客户端读通道）

**第四次挥手：**客户端A收到服务器发送的报文后，发送ACK确认报文，表示对B的释放请求发出确认，并且将确认序号设置为收到序号+1，然后进入TIME-WAIT时间等待状态。（关闭服务器写通道）

#### 1. 为什么会有TIME_WAIT 状态

超时时间为 2 * MSL, 为什么需要等待时间

**原因**

- 确保有足够的时间让对方收到 ACK包

  > 如果被动关闭的一方没有收到 ACK, 被动端就会重发 FIN包, 一来一去正好是 2个 MSL

- 避免新旧连接混淆

  > 有足够的时间让这个连接不会和后面的连接混在一起. 有些路由器会缓存IP数据包, 如果连接被重用了, 那么这些延迟收到的包,就有可能跟新连接混在一起

#### 2. 为什么需要四次握手才能断开连接

因为客户端的LISTEN状态下的SOCKET收到SYN报文的连接请求后，它可以把ACK和SYN放在一个报文里来发送。但关闭连接时，当收到对方的FIN通知时，它仅仅表示对方没有数据发送给你，但并不代表你不会给它发送数据，所以你可能不会立即关闭SOCKET，而是发送FIN报文给对方表示你同意现在可以关闭连接了，所以这里的ACK报文和FIN报文多数情况下是分开发送的。

因为全双工(允许在两个方向上同时传输), 发送发和接收方都需要 FIN报文和 ACK报文

也就是发送发和接收方都需要两次挥手即可, 不过有一方是被动的, 所以看上去是四次挥手

#### 3. 服务器出现大量 CLOSE_WAIT 状态的原因

客户端一直在请求,但是返回给客户端的信息出现异常, 服务端没有收到请求

也就是对方关闭 Socket连接, 我方忙于读或写, 没有即使关闭连接

###### 解决

- 检查代码, 特别是释放资源的代码
- 检查配置, 特别是处理请求的线程配置

> netstat 指令重要

### TCP/UDP区别

##### UDP 和 TCP 的特点

- 用户数据报协议 UDP（User Datagram Protocol）是**无连接的，尽最大可能交付，**没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 TCP（Transmission Control Protocol）是**面向连接的，提供可靠交付**，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

##### 结论

![TCP_UDP区别](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\TCP_UDP区别.png)

**补:** TCP是有序的, UDP是无序的



### TCP的滑动窗口

#### 两个概念

**RTT:** 发送一个数据包到收到对应的 ACK, 所花费的时间(时间差)

**RTO:** 重传时间间隔 

> RTO需要一个很好的算法来统计, 不是一个固定写死的配置, 而是经过 RTT 计算出来的, 有了 RTO才有了重传机制

#### TCP滑动窗口

要实现对数据批量发送, TCP必须解决可靠传输以及包乱序的问题

**TCP使用滑动窗口做流量控制与乱序重排**

#### 作用

- 保证TCP的可靠性
- 保证TCP的流控特性

> TCP报文头里面的 window字段, 用于接收方通知发送放自己还有多少缓冲区可以接受数据,发送发根据接收方的处理能力, 来发送数据,不会导致接收方处理不过来, 这便是流量控制

同时, 滑动窗口机制还体现了 TCP面向字节流的设计思路, 动态窗口的大小可以动态调整

#### TCP发送方的滑动窗口

![TCP发送方的滑动窗口](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\TCP发送方的滑动窗口.png)







1. 窗口是缓存的一部分，用来暂时存放字节流。
2. 发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
3. 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。
4. 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；
5. 接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。
6. 接收窗口只会对窗口内最后一个按序到达的字节进行确认，
7. 例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31}按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![滑动窗口](E:\Git\秋招_基础知识\计算机网络\图片\TCP_IP\滑动窗口.png)

### TCP 流量控制

流量控制是**为了控制发送方发送速率，保证接收方来得及接收**。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。

### TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![拥塞控制所起的作用](E:\Git\秋招_基础知识\计算机网络\图片\TCP_IP\拥塞控制所起的作用.png)