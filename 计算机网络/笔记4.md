## 简单说一下HTTP

HTTP 即超文本传输协议, 它是一个基于请求与响应模式的无状态的应用层的协议，常基于TCP的连接方式，HTTP1.1版本中,给出一种持续连接的机制`keep-alive`, 大多数的 web开发都是构建在 HTTP上面的Web应用 HTTP协议的主要特点概括如下

### 1. 支持客户/服务器模式

![CS模式](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\CS模式.png)

HTTP协议，工作于客户端服务端架构之上，浏览器作为HTTP客户端，通过url向HTTP服务端(即web服务器)上发送所有请求，web服务器根据接收到的请求向客户端发送响应信息

### 2. 简单快速

客户端向服务器请求服务的时候，只需传送请求方法和路径. 请求方法常用的有GET, POST，每种方法规定了客户与服务器连接的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快

### 3. 灵活

HTTP上允许传输任意类型的数据对象，正在传输的类型，有**加以标记

### 4. 无连接

无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求并收到客户的应答之后，立即断开连接，采用这种方式可以节省传输时间

从 HTTP1.1起默认使用了长连接(即服务器，需要等待一定时间后才断开连接，以保证连接特性)虽然目前的一些技术如 `keep-alive` 使用了长连接优化效率，但这些都是属于HTTP请求之外的，也就是说在每个独立的HTTP请求中，你是无法知道当前的HTTP是否处于长连接的状态，你始终都认为HTTP请求再结束后连接就会关闭，这是HTTP的特性，至于下层实现是否在结束请求后关闭连接都不会改变这个特性，长连接可以理解为下层实现对上层透明

### 5. 无状态

HTTP协议是无状态协议，无状态是指协议对于事物处理没有记忆能力，缺少状态意味着如果后续处理需要前面信息，则必须被重传，这样可能导致每次连接传送的数据量增大，另一方面呢，在服务器不需要先前信息时，它的应答就较快

> HTTP协议目前正处于多个版本共存的情况，包括被广泛参使用的 1.0， 主流最为广泛的 1.1，还有应用较少的2.0，1.1相较 1.0，最明显的区别是引用了 `keep-alive`长连接技术，2.0虽然更合理更先进，但是其推广不开来的原因也是因为 1.1完全能够满足目前的应用，并且升级上2.0的成本太大所导致的

### HTTP请求结构

![Http请求结构](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\Http请求结构.png)

#### 抓包

![HTTP请求实例](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\HTTP请求实例.png)

#### HTTP响应结构

![HTTP响应结构](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\HTTP响应结构.png)

#### 抓包

![HTTP响应头部示例](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\HTTP响应头部示例.png)

### 请求/响应步骤

1. 客户端连接到Web服务器
2. 发送HTTP请求
3. 服务器接受请求并返回HTTP响应
4. 释放连接TCP连接
5. 客户端浏览器解析HTML内容

## 二. 在浏览器地址栏键入 URL,按下回车之后经历的流程

### 1. DNS解析

根据URL逐层查询DNS服务器缓存, 解析URL域名所对应的IP地址。DNS缓存从近到远依次是，浏览器缓存，系统缓存, 路由器缓存, IPS服务器缓存, 根域名服务器缓存, 顶级域名服务器缓存, 从哪个缓存找到对应的IP，则直接返回，不再查询后面的缓存

### 2. TCP连接

紧接着呢，找到了IP地址之后呢，会根据你的IP地址和对应端口，默认是80端口,和服务器建立TCP连接，结合前面说的三次握手来讲解

### 3. 发送HTTP请求

之后浏览器会发出读取文件的HTTP请求. 该请求将发送给服务器

### 4. 服务器处理请求并返回HTTP报文

服务器对浏览器请求做出响应，并把对应的带有HTML文本的HTTP响应报文发送给浏览器

### 5. 浏览器解析渲染页面

之后浏览器收到了 HTML, 并在显示窗口内渲染它

### 6. 连接结束

最后浏览器释放TCP连接, 该步骤就是四次挥手

## 三. HTTP状态码

通过状态码大致判断问题出现的原因

![HTTP状态码](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\HTTP状态码.png)

### 常见状态码

![常见状态码](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\常用状态码2.png)

## 四. GET和 POST请求的区别

### 1. HTTP报文层面: GET将请求信息放在 URL， POST 放在报文体中

GET将请求信息放到URL后面，请求信息和URL之间用`?`隔开, 请求信息的格式为键值对

而POST请求方式，把请求信息放在报文中，想获得请求信息必须解析报文，因此安全性比GET方式要高一些，事实上,获得报文体中请求信息也是很容易的，因此安全性上，两者没有太多的区别.具体解决传输过程中的安全问题，还要靠HTTPS

###### eg:

```
https://www.bilibili.com/video/av58942818?spm_id_from=333.334.b_62696c695f646f756761.9
```

GET请求正文中没有参数, POST将参数放到请求正文里面去, 里面能够看到账号密码等信息,是明文的, 可以通过抓包的方式获取里面的信息, HTTP不是安全的

GET的请求方式在 URL中,因此是有长度限制的，因为虽然URL本身是没有长度限制的，但是浏览器(像 Chrom, Firefox这些)，会对URL的长度做出限制，POST中的请求信息是放置在报文中的，因此对数据强度是没有限制的

### 2.数据库层面层面: GET请求符合幂等性和安全性， POST不符合

**幂等性：** 对数据库的一次操作和多次操作的结果是一致的

**安全性：** 对数据库的操作没有改变数据库中的数据

GET操作是对数据库中的数据进行查询操作, POST请求会往数据库中提交数据

### 3. 其他层面: GET可以被缓存, 被存储,而POST不行

GET请求会被保存在浏览器的浏览记录中，URL能够被保存为书签。POST不具备上述功能, 缓存是GET 被广泛应用的根本。每天的上网量是巨大的，绝大多数都是 GET处理， 如果全部交由服务器处理，是巨大的资源浪费。GET是幂等的，安全的。因此绝大部分 GET请求（90%）都被CDN缓存了。就能大大减少Web服务器的负担。而POST必须交由服务器处理

## 五. Cookie 和 Session的区别

HTTP是无状态的,所以每次访问有登陆需求的页面,都要不厌其烦的输入账号密码,现实生活中并没有出现这样的情况,因为引入了某些机制, 让 HTTP变成有状态,其中两个便是 Cookie和Session

### Cookie 简介

##### 1. 由服务器发给客户端的特殊信息,以文本的形式存放在客户端. 

每次客户端向服务器发送请求的时候,都会带上这些特殊的信息

当用户使用浏览器访问一个支持 Cookie的网站时,用户会提供包括用户名在内的个人信息.并提交到服务器. 紧接着, 服务器在向回传超文本的同时,也会发回这些个人信息. 这些信息存放在 HTTP响应头中的,当浏览器接收到来自服务器的响应之后,浏览器会将信息存放在一个统一的位置.

##### 2. 客户端再次请求的时候, 会把 Cookie回发

至此, 浏览器再次向服务端发送请求的时候, 会把相应的Cookie发回给至服务器, 而这次, Cookie信息则存放在 HTTP请求头里面了

##### 3. 服务器接收到后会解析 Cookie生成与客户端相对应的内容

 服务器接收到来自客户端的浏览器的请求之后,就能够分析存放于请求头的 Cookie得到客户端特有的信息,从而动态生成与该客户端相对应的内容. 

通常很多网站在登陆的时候会出现请记住账号和密码,如果勾选了他, 之后再登陆.那么在下一次访问的时候,就不需要重复而繁琐的登陆动作了.这个功能,就是通过 Cookie 来实现的

###### Cookie的设置与发送过程

![Cookie的设置于发送过程](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\Cookie的设置于发送过程.png)

### Session

#### 1. 服务器端的机制,在服务器上保存的信息

Session机制是一种服务器端的机制, 服务器使用了一种类似于散列表的结构, 来保存信息.

#### 2. 解析客户端请求并操作session id ,按需保存状态信息

当程序需要为某个客户端的请求创建一个Session的时候, 服务器首先检查这个客户端的请求里,是否包含了一个Session标识. 成为 Seesion id, 如果已包含一个Session id,则说明以前已经为次客户端创建过 Session, 服务器就按照 Session id, 把这个Session 检索出来使用, 如果检索不到, 就会新建一个. 如果不包含一个Session id, 则为此客户端创建一个 Session. 并生成一个与此Session相关的 Session id. Session id的值应该是一个既不会重复, 有不容易被找到规律,以防止捏造的字符串. Seesion id 会在本次响应中回发给客户端进行保存.

#### Session的实现方式

有两种

##### 1.使用 Cooike的方式来实现

 服务器在给每个Session分配一个唯一的 JSESSIONID, 并通过 Cookie发送给客户端, 当客户端发起新的请求的时候, 将在Cookie头中携带 JESSIONID,这样服务器能够找到客户端对应的Session

###### 图示

![Session实现方式1](C:\Users\zn\Desktop\ALL\秋招\总复习\计算机网络\图片\Session实现方式1.png)

##### 2. 使用 URL回写来实现 

URL回写是指是服务器在发给浏览器页面的所有链接中, 都携带 JSESSIONID的参数.这样,客户端点击任何一个链接, 都会把 JESSIONID待会服务器, 如果直接在浏览器输入服务器资源的URL来请求该资源，那么 Session是匹配不到的。Tomcat对 Session的实现是使用 Cookie和 URL回写机制, 如果发现客户端支持 Cookie,就继续使用Cookie, 停止使用 URL回写, 如果发现 Cookie 被禁用, 就是用 URL回写

### Cookie 和 Session的区别

#### 1. Cookie数据存放在客户的浏览器上, Session数据放在服务器上

#### 2. Session相对于Cookie更安全

Cookie不是很安全, 别人可以分析存放在本地的 Cookie, 以进行 Cookie欺骗, 考虑到安全, 一般使用Session

#### 4. 若考虑减轻服务器负担,应当使用Cookie

Session会在一段时间内保存在服务器上,当访问增多.会占用服务器的性能

#### 