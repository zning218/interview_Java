# 你了解 Java的内存模型吗?

## 内存简介

计算机的所有程序都是在内存中运行的, 只不过内存包括虚拟内存和硬盘这样的外盘支持

#### JVM内存模型 (JDK8)

Java运行在虚拟机之上, 运行时需要内存空间, 虚拟机执行 Java程序的过程中, 会把他管理的内存划分为不同的区域, 方便管理

#### 从线程的角度看

* **线程私有:** 程序计数器, 虚拟机栈, 本地方法栈

* **线程共享:** MetaSpace, Java堆

![线程角度看虚拟机](./图片/线程角度看虚拟机.png)

## 1. 程序计数器(Program Counter Register)

* 当前线程所执行的字节码行号指示器 **(逻辑)**

* 改变计数器的值来选取下一条需要执行的字节码指令(比如, 循环, 判断, 跳转等指令, 线程恢复)

* 和线程是一对一的关系即”线程私有”

  > JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的.在任何一个确定的时刻, 一个处理器只会执行一条线程中的指令.因此为了线程切换后能恢复到之前的执行位置, 每一个线程都需要一个独立的程序计数器, 各条线程之间的计数器互不影响, 独立存储

* 对Java方法计数,如果是Native方法则计数器值为Undefined

* 不会发生内存泄露

  > 因为只是记录行号, 不必担心内存泄漏的问题

通俗来讲就是 每个线程都有一个计数器, 用来记录程序如何顺序执行, 很小, 不会发生内存泄漏

## 2. Java虚拟机栈

### 介绍

* Java方法执行的内存模型
* 包含多个栈帧

![Java栈](./图片/Java栈.png)

虚拟机栈也是线程私有的

每个方法执行时, 都会创建一个栈帧, 即方法运算时的基础数据结构

栈帧用于存储局部变量表, 操作栈, 动态链接, 方法出口等, 每个方法执行时, 对应虚拟机栈帧,入栈到出栈的过程. 

Java虚拟机栈用来存储栈帧, 栈帧持有局部变量和部分结果以及参与方法的调用及返回. 当方法调用结束时, 帧才会被销毁. 

虚拟机栈包含了单个线程执行的栈帧, 栈帧则存储了局部变量表, 操作栈, 动态链接, 方法出口等信息

![栈帧的结构](./图片/栈帧的结构.png)

> javap -verbose 口语话的形式来描述class文件中的内容

**局部变量表为操作数栈提供必要的数据支撑**

#### 简单例子

![栈的实例解析](./图片/栈的实例解析.png)

### 问题

#### 1. 递归为什么会引发 java.lang.StackOverflowError异常?  

​	当线程执行一个方法时,就会随之创建一个对应的栈帧, 并将栈帧压入虚拟机栈中, 当方法执行完毕的时候, 便会将栈帧出栈, 因此可知, 当线程当前执行的方法所对应的栈帧必定位于 Java栈的顶部, 如果栈帧数超出虚拟栈的深度, 就会造成栈溢出

**eg:** 递归过深, 栈帧数超出虚拟栈深度, 解决思路是限制递归次数, 或者使用循环

#### 2. 虚拟机栈过多会引发 java.lang.OutOfMemoryError异常

当虚拟机栈可以动态扩展时,如果无法申请足够多的内存, 就会抛出此异常(内存溢出) 

虚拟机栈也是 Java虚拟机自动管理的, 栈类似一个集合, 但是是有固定容量的, 是由多个栈帧合起来的, 在编写代码的时候, 每编写一个方法, 在运行的时候, Java虚拟机会自动在内存中分配一块空间, 就是一个栈帧, 方法调用后, 对应的栈帧就会被自动释放掉. 这就是我们所说的栈的内存不需要GC去回收,而是自动释放的原因.



## 3. 本地方法栈

和虚拟机栈十分类似, 标注了 native的方法用的是本地方法栈



## 4. 元空间 (MetaSpace)

#### 1. 元空间和永久代(PermGen)的区别

​	在 JDK8以后呢, **开始把类的元数据放在本地内存中**,这一块区域就叫元空间, 该区域在JDK7及以前是属于永久代的. **元空间和永久代都是用来存储Class的相关信息, 包括 class的method和 field.** **元空间和永久代都是方法区的实现.**只是实现有所不同, **方法区只是 JVM的一种规范**, 在JDK7之后, **原先位于方法区里面的字符串常量池被移到了Java堆中.** 并且在JDK8之后, 使用元空间替代了永久代, 替代并不是名字的替代

**元空间使用本地内存, 而永久代使用的是 JVM的内存**

​	好处是老版本的异常`java.lang.OutOfMemoryError:PermGen space` 将不存在,因为默认的类的元数据分配只受本地内存大小的限制, 解决了空间不足的问题, JVM会默认在运行时会根据需要动态的设置其大小

#### 2. MetaSpace相比 PermGen的代勢

* 字符串常量池存在永久代中,容易出现性能问题和内存溢出
* 类和方法的信息大小难以确定, 给永久代的大小指定帯来困雉
* 永久代会为GC带来不必要的复杂性
* 方便HotSpot与其他JVM如Jrockit的集成



## 5. 堆(Heap)

#### 对象实例的分配区域

​	堆是 Java虚拟机中管理的最大的一块区域, 是被所有线程共享的一块内存区域, 在虚拟机启动时创建, 此内存区域的**唯一目的就是存放对象实例**, 几乎所有的对象实例都在这里分配内存

​	Java虚拟机规范Java堆可以处于**物理上不连续的内存空间中, 只要逻辑上是连续的即可,** 就像磁盘空间一样, 在实现时, 既可以实现成固定大小的, 也可以是可扩展的. 不过当前流行的虚拟机都是按照可扩展来实现的.即通过    `-Xmx -Xss` 去控制. 如果在堆中没有完成实例分配, 并且堆也无法再扩展时, 将会抛出 `java.lang.OutOfMemoryError`异常

![堆的分配区域](./图片/堆的分配区域.png)

#### GC管理的主要区域

​	Java堆是GC管理的主要区域, 因此很多时候也被成为 GC堆, 如果从内存回收的角度看, 现在收集器都是采用分代收集算法. 所以Java堆中还可细分为新生代和老年代.

![回收角度_堆的分配]((C:/Users/zn/Desktop/ALL/秋招/总复习/Java/JVM/JVM底层(翔仔))/图片/回收角度_堆的分配.png)



# JVM三大性能调优参数的含义

在调用 Java指令去执行程序的时候, 通过以上三个参数, 分别调整Java堆, 以及线程所占内存大小

`-Xss` : 规定了每个线程虚拟机栈的大小

> -Xss: 一般情况下 256K足够了,影响此进程中并发线程数的大小

`-Xms` :堆的初始值

> Java刚创建出来的时候, 堆的大小, 一旦堆的容量超过了初始容量, 将会自动扩容, 扩容至堆能达到的最大值	`-Xmx`

`-Xmx` :堆能达到的最大值

> 通常情况下将 -Xms 和 -Xmx 设置为一样的, 因为当 heap不够用发生扩容时,会发生内存抖动, 影响程序运行时的稳定性



# Java内存中模型中堆和栈的区别

### 内存分配策略(静态, 栈式, 堆式)

**静态存储:** 编译时确定每个数据目标在运行时的存储空间需求

> 因而, 在编译时就能够分配固定的内存空间, 这种分配策略, 要求程序代码中, 不允许有可变数据结构的存在, 也不允许有嵌套或递归的结构存在, 因为他们都会导致编译程序无法计算正确的存储空间

**栈式存储:** 数据区需求在编译是未知, 运行时模块入口前确定

> 该分配可称为动态的可存储分配, 是由一个类似堆栈的运行栈来实现的, 和静态分配的方式相反, 在此方案中, 程序对数据区的要求在编译时是完全未知的,只有到了运行时才能知道, 但是规定在运行中, 进入一个程序模块的时候, 必须知道该程序模块所需要数据区域的大小, 才能分配其内存, 和数据结构的栈一样, 先进后出

**堆式存储:** 编译时或运行时模块入口都无法确定, 动态分配

> 专门负责在编译时或运行时模块入口都无法确定存储要求的数据结构的内存分配.比如可变**串(没听清)和对象实例. 堆有大片的可利用块和空闲块组成, 堆中的内存可以按照任意的顺序分配和释放 )

### 堆和栈的区别

##### 联系:引用对象、数组时,栈里定义变量保存堆中目标的首地址

![栈, 堆的存储模型](./图片/栈, 堆的存储模型.png)

​	创建好的对象实例(和数组)都会保存在堆中, 先要引用堆中的某个对象(或数组),可以在栈中定义一个特殊的变量, 让栈中这个变量的取值等于堆中对象(数组)的首地址, 栈中的这个变量就变成了引用变量. 以后就可以在程序中使用栈中的引用变量来访问对象(或数组)

​	引用变量是普通的变量, 定义时在栈中分配. 引用变量在程序运行到其作用域外之后, 就会被释放掉. 而对象(和数组)在堆中分配. 即使程序运行到使用 new产生数组或者对象所在的语句代码块之外, 数组和对象本身占据的内存不会被释放.他们在没有引用变量指向的时候, 才会变为垃圾, 在随后的不确定的时间被垃圾回收器释放掉. 

#### 区别

- **管理方式:** 栈自动释放,堆需要GC

  > JVM可以针对内存栈进行管理操作, 而且该释放是有编译器就可以直接操作的内容. 而堆空间在Java中, JVM本身执行引擎不会对其进行释放操作. 而是让垃圾回收器进行回收

- **空间大小:** 栈比堆小

  > 一般情况下, 栈空间相较于对空间要小, 这是由栈空间存储的数据以及本身需要的数据特性决定的. 而堆空间在JVM对实例进行分配的时候一般大小都比较大

- **碎片相关:** 栈产生的碎片远小于堆

  > 堆空间相对于栈空间活动量比较大, 有可能存在长期的对空间分配和释放操作. 而且垃圾回收器不是实时的.可能使得堆中的垃圾碎片逐渐累积起来
  >
  > 栈空间而言, 因为本身就是一个堆栈的数据结构, 他的操作都是一一对应的. 而且每一个最小单位的结构栈帧和堆中的复杂结构不一样. 所以在还是用过程中很少出现内存碎片

- **分配方式:**栈支持静态和动态分配,而堆仅支持动态分配

  > 栈空间的静态分配是编译器本身分配好了, 和动态分配可能根据情况有所不同. 不需要我们考虑释放的问题
  >
  > 堆空间是完全动态分配的, 即使在有垃圾回收的前提下. 需要考虑释放的问题

- **效率:**栈的效率比堆高

  > 因为内存块本身的排列就是一个典型的栈结构, 所以栈空间比堆空间的效率高很多, 而且计算机内存底层本身就使用了最基本的堆栈结构. 使得栈空间和底层结构更加符合. 操作也变得简单. 因为只设计到两个最简单的指令, 入栈和出栈. 
  >
  > 栈空间针对堆空间的弱点是灵活程度不够. 特别是在动态绑定的时候. 而堆空间最大的优点在于动态分配.因为他在计算机底层实现了可能是双向链表的结构, 所以在操作管理的时候比栈复杂很多. 自然灵活度就高了, 但是效率就不急栈空间了, 要低很多

## 元空间, 堆, 线程独占部分间的联系 — 内存角度

###### 代码

```java
public class HelloWorld {
    private String name;
    public void sayHello() {
        System.out.println("hello" + name);
    }
    public void setName(String name) {
        this.name = name;
    }
    
    public static void main(String[] args) {
        int a = 1;
        HelloWorld hw = new HelloWorld();
        hw.setName("test");
        hw.sayHello();
    }
}
```

###### 分析图

![内存分配](./图片/内存分配.png)

